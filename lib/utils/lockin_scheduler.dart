
import '../models/lockin.dart';
import '../services/lockin_service.dart';
import 'package:logger/logger.dart';

class LockInScheduler {
  final LockInService _lockInService = LockInService();
  final Logger _logger = Logger(
    printer: PrettyPrinter(
      methodCount: 2,
      errorMethodCount: 8,
      lineLength: 120,
      colors: true,
      printEmojis: true,
      dateTimeFormat: DateTimeFormat.none,
    ),
  );

  /// Public method for testing: generates instances for a LockIn (for test only)
  List<LockInInstance> generateInstancesForTest(LockIn lockIn, int daysAhead) {
    return _generateInstances(lockIn, daysAhead);
  }

  /// Creates instances for a LockIn based on its frequency
  /// This can be called when a LockIn is created or when updating schedules
  Future<void> createInstancesForLockIn(LockIn lockIn, {int daysAhead = 30}) async {
    final instances = _generateInstances(lockIn, daysAhead);
    
    for (final instance in instances) {
      try {
        await _lockInService.createLockInInstance(lockIn.id, instance);
      } catch (e) {
        // Log error but continue with other instances
        _logger.e('Error creating instance for ${lockIn.title}: $e');
      }
    }
  }

  /// Generates instances based on the LockIn's frequency
  List<LockInInstance> _generateInstances(LockIn lockIn, int daysAhead) {
    final instances = <LockInInstance>[];
    final now = DateTime.now();
    final endDate = now.add(Duration(days: daysAhead));
    
    // Parse reminder time
    final timeParts = lockIn.reminderTime.split(':');
    final reminderHour = int.parse(timeParts[0]);
    final reminderMinute = int.parse(timeParts[1]);

    DateTime currentDate;
    int incrementDays;

    switch (lockIn.frequency.toLowerCase()) {
      case 'daily':
        // Start from today
        currentDate = DateTime(now.year, now.month, now.day);
        incrementDays = 1;
        break;
      case 'weekly':
        // Start from today
        currentDate = DateTime(now.year, now.month, now.day);
        incrementDays = 7;
        break;
      case 'biweekly':
        // Start from today
        currentDate = DateTime(now.year, now.month, now.day);
        incrementDays = 14;
        break;
      case 'monthly':
        // Start from today
        currentDate = DateTime(now.year, now.month, now.day);
        incrementDays = 30; // Approximation for monthly
        break;
      default:
        currentDate = DateTime(now.year, now.month, now.day);
        incrementDays = 1;
    }

    while (currentDate.isBefore(endDate) || currentDate.isAtSameMomentAs(DateTime(endDate.year, endDate.month, endDate.day))) {
      final scheduledDateTime = DateTime(
        currentDate.year,
        currentDate.month,
        currentDate.day,
        reminderHour,
        reminderMinute,
      );

      // Create instances for today and future dates
      if (currentDate.isAtSameMomentAs(DateTime(now.year, now.month, now.day)) || currentDate.isAfter(DateTime(now.year, now.month, now.day))) {
        instances.add(LockInInstance(
          id: '', // Will be generated by Firestore
          scheduledFor: scheduledDateTime,
          completedAt: null,
          mediaUrl: null,
          status: 'pending',
        ));
      }

      currentDate = currentDate.add(Duration(days: incrementDays));
    }

    return instances;
  }

  /// Gets the next scheduled instance for a LockIn
  Future<LockInInstance?> getNextInstance(String lockInId) async {
    try {
      final instances = await _lockInService.getLockInInstances(lockInId).first;
      final now = DateTime.now();
      
      // Find the next pending instance
      final pendingInstances = instances
          .where((instance) => 
              instance.status == 'pending' && 
              instance.scheduledFor.isAfter(now))
          .toList();
      
      if (pendingInstances.isEmpty) return null;
      
      // Sort by scheduled time and return the earliest
      pendingInstances.sort((a, b) => a.scheduledFor.compareTo(b.scheduledFor));
      return pendingInstances.first;
    } catch (e) {
      print('Error getting next instance: $e');
      return null;
    }
  }

  /// Marks overdue instances as missed
  Future<void> markOverdueInstancesAsMissed(String lockInId) async {
    try {
      final instances = await _lockInService.getLockInInstances(lockInId).first;
      final now = DateTime.now();
      
      // Find overdue pending instances (more than 24 hours past scheduled time)
      final overdueInstances = instances
          .where((instance) => 
              instance.status == 'pending' && 
              now.difference(instance.scheduledFor).inHours > 24)
          .toList();
      
      for (final instance in overdueInstances) {
        await _lockInService.markLockInInstanceAsMissed(lockInId, instance.id);
      }
    } catch (e) {
      print('Error marking overdue instances: $e');
    }
  }

  /// Gets completion statistics for a LockIn
  Future<Map<String, int>> getLockInStats(String lockInId) async {
    try {
      final instances = await _lockInService.getLockInInstances(lockInId).first;
      
      final completed = instances.where((i) => i.status == 'completed').length;
      final missed = instances.where((i) => i.status == 'missed').length;
      final pending = instances.where((i) => i.status == 'pending').length;
      
      return {
        'completed': completed,
        'missed': missed,
        'pending': pending,
        'total': instances.length,
      };
    } catch (e) {
      print('Error getting LockIn stats: $e');
      return {'completed': 0, 'missed': 0, 'pending': 0, 'total': 0};
    }
  }
}
